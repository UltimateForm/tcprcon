package cmd

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"github.com/UltimateForm/tcprcon/internal/ansi"
	"github.com/UltimateForm/tcprcon/internal/fullterm"
	"github.com/UltimateForm/tcprcon/internal/logger"
	"github.com/UltimateForm/tcprcon/pkg/packet"
	"github.com/UltimateForm/tcprcon/pkg/rcon"
)

func runRconTerminal(client *rcon.Client, ctx context.Context, logLevel uint8) {
	app := fullterm.CreateApp(fmt.Sprintf("rcon@%v", client.Address))
	// dont worry we are resetting the logger before returning
	logger.SetupCustomDestination(logLevel, app)

	appErrors := make(chan error, 1)
	connectionErrors := make(chan error, 1)

	appRun := func() {
		appErrors <- app.Run(ctx)
	}
	packetChannel := packet.CreateResponseChannel(client, ctx)
	packetReader := func() {
		for {
			select {
			case <-ctx.Done():
				return
			case streamedPacket := <-packetChannel:
				if streamedPacket.Error != nil {
					if errors.Is(streamedPacket.Error, os.ErrDeadlineExceeded) {
						logger.Debug.Println("read deadline reached; connection is idle or server is silent.")
						continue
					}
					if errors.Is(streamedPacket.Error, io.EOF) {
						connectionErrors <- io.EOF
						return
					}
					logger.Err.Println(errors.Join(errors.New("error while reading from RCON client"), streamedPacket.Error))
					continue
				}
				fmt.Fprintf(
					app,
					"(%v): RCV PKT %v\n%v\n",
					ansi.Format(strconv.Itoa(int(streamedPacket.Id)), ansi.Green, ansi.Bold),
					ansi.Format(strconv.Itoa(int(streamedPacket.Type)), ansi.Green, ansi.Bold),
					ansi.Format(strings.TrimRight(streamedPacket.BodyStr(), "\n\r"), ansi.Green),
				)
			}
		}
	}
	submissionChan := app.Submissions()
	submissionReader := func() {
		for {
			select {
			case <-ctx.Done():
				return
			case cmd := <-submissionChan:
				execPacket := packet.New(client.Id(), packet.SERVERDATA_EXECCOMMAND, []byte(cmd))
				fmt.Fprintf(
					app,
					"(%v): SND CMD %v\n",
					ansi.Format(strconv.Itoa(int(client.Id())), ansi.Green, ansi.Bold),
					ansi.Format(cmd, ansi.Blue),
				)
				client.Write(execPacket.Serialize())
			}
		}
	}
	go submissionReader()
	go packetReader()
	go appRun()

	select {
	case <-ctx.Done():
		logger.Debug.Println("context done")
		break
	case err := <-connectionErrors:
		defer func() {
			logger.Critical.Println(errors.Join(errors.New("connection error"), err))
		}()
		break
	case err := <-appErrors:
		// lets do this because the app might be unrealiable at this point
		if err != nil {
			defer func() {
				logger.Critical.Println(errors.Join(errors.New("app error"), err))
			}()
		} else {
			defer func() {
				logger.Debug.Println("graceful app exit")
			}()
		}
		break
	}
	app.Close()
	logger.Setup(logLevel)
}
